// start to learn ES6

// let
// 声明的变量作用域只在代码块内生效，不会发生变量提升。
// 一般用于for循环中
// for(let i=0; i < 10; i++) {
//     console.log(i);
// }

// var a = [];
// for(var i = 0; i < 10; i++) {
//     a[i] = function() {
//         console.log(i);
//     }
// }

// a[6]();


// 变量提升：在编译阶段变量被放入内存。
// 这么做的好处是，从代码顺序上来看，你可以先使用函数，然后再声明函数(但是必须要有)。
// 但是这么做违背了Best Prictise，应该先声明后使用。
// 值得注意的是，变量提升，提升的是声明，而非初始化。

// 暂时性死区(TDZ, temporal dead zone)
// ES6明确规定，如果在区块中使用let和const命令，使用let和const在所在区块中声明的变量，一开始就形成了封闭作用域。
// 所以，在块内对let和const声明的变量之前操作变量就会报错。
// 暂时性死区的范围是，从代码块开始，到声明变量结束。
// 需要注意的是：在暂时性死区中，不能使用typeof()函数，会得到ReferenceError异常。
// typeof abc;
// let abc = "123";
// 但是，如果这个变量根本没有被声明，那么typeof abc;则会得到undefined。

// ES6中为什么要引入let和const呢？
// 因为let和const可以避免变量提升，界定暂时性死区，从而规范开发者编码习惯。
// 而且这会减少运行时错误(在声明前使用，导致无法预料的结果)。

// let不允许在相同的作用域内声明同名变量。否则会报错。


// ES6中引入了块级作用域
// ES5中只有全局作用域和函数作用域，导致一些场景出现了不合理的现象。
// 场景1：
// 在函数内部使用一个未被声明的变量，导致了变量提升，也就是后来的变量覆盖了之前的变量。
// 场景2：
// for循环内声明的变量泄露到全局变量，比如for(var i=0; i<10; i++)中的i。
// 在for循环体执行完毕后，变量i没有被回收，在全局作用域内仍然可以访问。

// ES6中允许嵌套任意多个代码块，外层作用域的变量无法读取内层作用域的变量。
// 创建代码块常见的办法是使用一对{}。


// 立即执行函数表达式(IIFE)？
// 用()将函数体包裹起来，就像这样 (function() { //something to do })
// 可以使用块级作用域替代，比如这样 { //something to do }

// 那么在块级作用域中是否可声明函数？
// ES5中规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。
// 但是各大浏览器并未遵循此约定，所以在块级作用域中声明的函数仍然生效，但是在严格模式(strict mode)下会报错。
// 可以使用'use strict'，开启严格模式。

// 那么在ES6中函数可以在块级作用域中声明么？
function f() {
    console.log("outside funciton.");
}

// 在chrome中会报错，其他浏览器的支持也各不相同，所以，尽量避免在块级作用域中声明函数。
// (function() {
//     if(false) {
//         function f() {
//             console.log("inside funciton.");
//         }
//     }
//     f();
// }());


// 函数声明和函数表达式的区别？
// 函数声明语句：function f() { //something to do }
// 函数表达式：let f = function() { //something to do }
// ES6中，块级作用域允许函数声明语句，但是必须在{}中声明。


// do表达式（暂时是个提案）
// do的作用是让块级作用域有一个返回值，可以让块以外的地方访问块内的变量。
// var x = do { let x = 10; }


// const
// 声明一个常量，一旦声明无法被修改。这意味着必须在声明的时候进行初始化。
// const声明的变量也是块级作用域。
// 改变常量会引发TypeError异常，“TypeError: Assignment to constant variable.”
// 需要注意：如果const声明了一个符合类型的变量a，a的地址是不变的，但是地址中的内容可以改变。比如array，dictionary。


// 对象冻结
// 使用const创建的对象只能保证一直指向这个对象，无法阻止其被修改。
// 可以使用let obj = Object.freeze({});来创建对象。
// 当给obj赋值时就会不起作用，而在严格模式下会报错(仅在严格模式下)。


// 顶层对象属性
// 在浏览器环境，顶层对象属性指的是window对象，在nodejs指的是global对象。
// 在ES5中，顶层对象的属性等价于全局变量。
// 在ES6中，顶层对象的属性和全局变量分离，不能再通过global.attr来获取了。
// var g = 200;
// console.log(g);
// console.log(global.g);
// let h = 300;
// console.log(h);
// console.log(global.h);
