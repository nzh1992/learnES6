// start to learn ES6

// let
// 声明的变量作用域只在代码块内生效，不会发生变量提升。
// 一般用于for循环中
// for(let i=0; i < 10; i++) {
//     console.log(i);
// }

// var a = [];
// for(var i = 0; i < 10; i++) {
//     a[i] = function() {
//         console.log(i);
//     }
// }

// a[6]();


// 变量提升：在编译阶段变量被放入内存。
// 这么做的好处是，从代码顺序上来看，你可以先使用函数，然后再声明函数(但是必须要有)。
// 但是这么做违背了Best Prictise，应该先声明后使用。
// 值得注意的是，变量提升，提升的是声明，而非初始化。

// 暂时性死区(TDZ, temporal dead zone)
// ES6明确规定，如果在区块中使用let和const命令，使用let和const在所在区块中声明的变量，一开始就形成了封闭作用域。
// 所以，在块内对let和const声明的变量之前操作变量就会报错。
// 暂时性死区的范围是，从代码块开始，到声明变量结束。
// 需要注意的是：在暂时性死区中，不能使用typeof()函数，会得到ReferenceError异常。
// typeof abc;
// let abc = "123";
// 但是，如果这个变量根本没有被声明，那么typeof abc;则会得到undefined。

// ES6中为什么要引入let和const呢？
// 因为let和const可以避免变量提升，界定暂时性死区，从而规范开发者编码习惯。
// 而且这会减少运行时错误(在声明前使用，导致无法预料的结果)。

// let不允许在相同的作用域内声明同名变量。否则会报错。


// ES6中引入了块级作用域
// ES5中只有全局作用域和函数作用域，导致一些场景出现了不合理的现象。
// 场景1：
// 在函数内部使用一个未被声明的变量，导致了变量提升，也就是后来的变量覆盖了之前的变量。
// 场景2：
// for循环内声明的变量泄露到全局变量，比如for(var i=0; i<10; i++)中的i。
// 在for循环体执行完毕后，变量i没有被回收，在全局作用域内仍然可以访问。

// ES6中允许嵌套任意多个代码块，外层作用域的变量无法读取内层作用域的变量。
// 创建代码块常见的办法是使用一对{}。


// 立即执行函数表达式(IIFE)？
// 用()将函数体包裹起来，就像这样 (function() { //something to do })
// 可以使用块级作用域替代，比如这样 { //something to do }

// 那么在块级作用域中是否可声明函数？
// ES5中规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。
// 但是各大浏览器并未遵循此约定，所以在块级作用域中声明的函数仍然生效，但是在严格模式(strict mode)下会报错。









